<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 服务端与客户端敏感数据通信的最佳实践 · wkchen's blog</title><meta name="description" content="服务端与客户端敏感数据通信的最佳实践 - wkchen"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.tipdev.xyz/atom.xml" title="wkchen's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">TIMELINE</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">服务端与客户端敏感数据通信的最佳实践</h1><div class="post-info">Jun 22, 2017</div><div class="post-content"><h3 id="对称加密方式（例如AES）"><a href="#对称加密方式（例如AES）" class="headerlink" title="对称加密方式（例如AES）"></a>对称加密方式（例如AES）</h3><p>对称加密方式通过密码（secret key）对敏感数据进行加密，比如考虑到用户登录时账号以及密码不利于暴露出来，可以通过对称加密的方式传递，客户端把敏感数据进行加密后发送给服务端，服务端使用相同的密码进行解密，这样即使在数据传输的时候被拦截了发送的数据，也不会完全的暴露出来，所以它不知道密码就无法进行解密数据。</p>
<p>当然这种加密方式存在最致命的缺点，一旦密码（secret key）被暴露就相当于把敏感数据直接公布出来了。</p>
<h3 id="非对称加密（例如：RSA）"><a href="#非对称加密（例如：RSA）" class="headerlink" title="非对称加密（例如：RSA）"></a>非对称加密（例如：RSA）</h3><p>非对称加密是生成一个私钥和一个公钥，公钥用于对敏感数据加密，私钥用于数据解密，并且只能使用私钥进行解密。这将意味着可以安全的在程序中运送公钥。</p>
<p>优点：安全性高<br>缺点：一次只能加密非常小的数据文本（128个字节）</p>
<h3 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h3><p>混合模式结合了对称模式和非对称模式的优点，我们首先在服务端使用RSA生成公钥和私钥；在客户端使用AES生成密码（secret key），使用密码对敏感数据进行加密，得到敏感数据密文（encrypted text），接着依然在客户端获取服务端生成的公钥，对AES密码（secret key）进行加密，得到AES密钥密文（encrypted secret key），然后把敏感信息密文（encrypted text） 和 AES密钥密文（encrypted secret key）  传递给服务器；最后回到服务端，使用私钥对AES密钥密文（encrypted secret key）进行解密，得到密码（secret key），最后使用密码（secret key）对敏感信息密文（encrypted text）进行解密，得到敏感数据。</p>
<p>好吧，我知道有点绕，没关系，我总结了一下几点：</p>
<ol>
<li>服务端RSA生成【公钥】和【私钥】，私钥存储服务端。</li>
<li>客户端使用【AES密码】对【敏感数据】加密，得到【RSA敏感数据密文】</li>
<li>客户端使用【公钥】对【AES密码】进行加密，得到【AES密码密文】</li>
<li>服务端使用【私钥】对【AES密码密文】解密，得到【AES密码】</li>
<li>服务端使用【AES密码】对【RSA敏感数据密文】，得到【敏感数据】</li>
</ol>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>​    这样就有效的解决了客户端和服务端敏感数据传递存在的安全隐患，这不仅仅是一个解决方案，更应该是每个开发者遵循的一项责任。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/08/24/2017-08-24-Use Dagger2.11 in MVP/" class="prev">PREV</a><a href="/2017/05/31/2017-05-31-GitLab搭建记录/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://www.tipdev.xyz">wkchen</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>