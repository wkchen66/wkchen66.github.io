<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android Native层静态数据安全加密 · wkchen's blog</title><meta name="description" content="Android Native层静态数据安全加密 - wkchen"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.tipdev.xyz/atom.xml" title="wkchen's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">TIMELINE</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android Native层静态数据安全加密</h1><div class="post-info">Feb 1, 2018</div><div class="post-content"><p>整体思路：so 文件在加载时会自动加载 JNI_OnLoad() ，在该方法中对应用签名进行比较，如果签名验证失败，直接在 JNI_OnLoad() 中返回失败。如果验证通过就可以通过 JNI 调用方法获取相应的值。这样可畏是既解决了通常的数据外泄，又解决了 so 文件被提取二次打包造成的重要数据外泄。</p>
<h4 id="加载-so-文件入口"><a href="#加载-so-文件入口" class="headerlink" title="加载 so 文件入口"></a>加载 so 文件入口</h4><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">JNIEXPORT jint JNICALL</div><div class="line">JNI_OnLoad(JavaVM *vm, <span class="keyword">void</span> *reserved) &#123;</div><div class="line">    JNIEnv *env;</div><div class="line">    LOGI(<span class="string">"  JNI_OnLoad  "</span>);</div><div class="line">    <span class="keyword">if</span> (vm-&gt;GetEnv((<span class="keyword">void</span> **) (&amp;env), JNI_VERSION_1_6) != JNI_OK) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    LOGI(<span class="string">"start checkSignature"</span>);</div><div class="line">    <span class="comment">// 调用验证签名</span></div><div class="line">    <span class="keyword">if</span> (checkSignature(env) != JNI_TRUE) &#123;</div><div class="line">        LOGI(<span class="string">"checkSignature error"</span>);</div><div class="line">        <span class="comment">// 签名失败</span></div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> JNI_VERSION_1_6;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当签名失败的时候，表示 so 文件加载失败，无法执行后续操作，比如获取 token md5加密 key</p>
<h4 id="通过-Java-反射获取-Context"><a href="#通过-Java-反射获取-Context" class="headerlink" title="通过 Java 反射获取 Context"></a>通过 Java 反射获取 Context</h4><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">checkSignature</span><span class="params">(JNIEnv *env)</span> </span>&#123;</div><div class="line">    <span class="comment">// 1.查找 App 的 ContextHolder 类</span></div><div class="line">    jclass classNativeContextHolder = env-&gt;FindClass(CLASS_NAME_NATIVECONTEXT);</div><div class="line">    <span class="comment">// 2.找到 getContext 静态方法</span></div><div class="line">    jmethodID midGetContext = env-&gt;GetStaticMethodID(classNativeContextHolder,</div><div class="line">                                                     METHOD_NAME_GET_CONTEXT,</div><div class="line">                                                     METHOD_SIGNATURE_GETCONTEXT);</div><div class="line">    <span class="comment">// 3.调用 getContext 方法获取 Context 对象</span></div><div class="line">    jobject appContext = env-&gt;CallStaticObjectMethod(classNativeContextHolder, midGetContext);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (appContext != <span class="literal">NULL</span>) &#123;</div><div class="line">        jboolean signatureValid = Java_com_laipaiya_jni_MainActivity_checkSignature(</div><div class="line">                env, appContext);</div><div class="line">        <span class="keyword">return</span> signatureValid;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> JNI_FALSE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用 Java_com_laipaiya_jni_MainActivity_checkSignature 方法比较签名是否想用。</p>
<h4 id="比较当前签名和-release-签名"><a href="#比较当前签名和-release-签名" class="headerlink" title="比较当前签名和 release 签名"></a>比较当前签名和 release 签名</h4><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> JNIEXPORT jboolean JNICALL</div><div class="line">Java_com_laipaiya_jni_MainActivity_checkSignature(</div><div class="line">        JNIEnv *env, jobject context) &#123;</div><div class="line">    jstring appSignature = loadSignature(env, context);          <span class="comment">// 获取当前签名</span></div><div class="line">    jstring releaseSignature = env-&gt;NewStringUTF(APP_SIGNATURE); <span class="comment">// release 版签名 </span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *charAppSignature = env-&gt;GetStringUTFChars(appSignature, <span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *charReleaseSignature = env-&gt;GetStringUTFChars(releaseSignature, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    LOGI(<span class="string">"  start cmp  getSignature"</span>);</div><div class="line">    __android_log_print(ANDROID_LOG_INFO, LOG_TAG, charAppSignature);</div><div class="line">    LOGI(<span class="string">"  start cmp  getReleaseSignature"</span>);</div><div class="line">    __android_log_print(ANDROID_LOG_INFO, LOG_TAG, charAppSignature);</div><div class="line"></div><div class="line">    jboolean result = JNI_FALSE;</div><div class="line">    <span class="comment">// 判断比较是否相等</span></div><div class="line">    <span class="keyword">if</span> (charAppSignature != <span class="literal">NULL</span> &amp;&amp; charReleaseSignature != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(charAppSignature, charReleaseSignature) == <span class="number">0</span>) &#123;</div><div class="line">            result = JNI_TRUE;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    env-&gt;ReleaseStringUTFChars(appSignature, charAppSignature);</div><div class="line">    env-&gt;ReleaseStringUTFChars(releaseSignature, charReleaseSignature);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="获取当前签名"><a href="#获取当前签名" class="headerlink" title="获取当前签名"></a>获取当前签名</h4><p>获取当前 App 签名，并调用 md5 方法 进行加密</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function">jstring <span class="title">loadSignature</span><span class="params">(JNIEnv *env, jobject context)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获得Context类</span></div><div class="line">    jclass cls = env-&gt;GetObjectClass(context);</div><div class="line">    <span class="comment">// 得到getPackageManager方法的ID</span></div><div class="line">    jmethodID mid = env-&gt;GetMethodID(cls, <span class="string">"getPackageManager"</span>,</div><div class="line">                                     <span class="string">"()Landroid/content/pm/PackageManager;"</span>);</div><div class="line">    <span class="comment">// 获得应用包的管理器</span></div><div class="line">    jobject pm = env-&gt;CallObjectMethod(context, mid);</div><div class="line"></div><div class="line">    <span class="comment">// 得到getPackageName方法的ID</span></div><div class="line">    mid = env-&gt;GetMethodID(cls, <span class="string">"getPackageName"</span>, <span class="string">"()Ljava/lang/String;"</span>);</div><div class="line">    <span class="comment">// 获得当前应用包名</span></div><div class="line">    jstring packageName = (jstring) env-&gt;CallObjectMethod(context, mid);</div><div class="line">    <span class="comment">// 获得PackageManager类</span></div><div class="line">    cls = env-&gt;GetObjectClass(pm);</div><div class="line">    <span class="comment">// 得到getPackageInfo方法的ID</span></div><div class="line">    mid = env-&gt;GetMethodID(cls, <span class="string">"getPackageInfo"</span>,</div><div class="line">                           <span class="string">"(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;"</span>);</div><div class="line">    <span class="comment">// 获得应用包的信息</span></div><div class="line">    jobject packageInfo = env-&gt;CallObjectMethod(pm, mid, packageName, <span class="number">0x40</span>);        </div><div class="line">    <span class="comment">// 获得PackageInfo 类</span></div><div class="line">    cls = env-&gt;GetObjectClass(packageInfo);</div><div class="line">    <span class="comment">// 获得签名数组属性的ID</span></div><div class="line">    jfieldID fid = env-&gt;GetFieldID(cls, <span class="string">"signatures"</span>, <span class="string">"[Landroid/content/pm/Signature;"</span>);</div><div class="line">    <span class="comment">// 得到签名数组</span></div><div class="line">    jobjectArray signatures = (jobjectArray) env-&gt;GetObjectField(packageInfo, fid);</div><div class="line">    <span class="comment">// 得到签名</span></div><div class="line">    jobject signature = env-&gt;GetObjectArrayElement(signatures, <span class="number">0</span>);</div><div class="line">    <span class="comment">// 获得Signature类</span></div><div class="line">    cls = env-&gt;GetObjectClass(signature);</div><div class="line">    <span class="comment">// 得到toCharsString方法的ID</span></div><div class="line">    mid = env-&gt;GetMethodID(cls, <span class="string">"toByteArray"</span>, <span class="string">"()[B"</span>);</div><div class="line">    <span class="comment">// 返回当前应用签名信息</span></div><div class="line">    jbyteArray signatureByteArray = (jbyteArray) env-&gt;CallObjectMethod(signature, mid);</div><div class="line">    <span class="keyword">return</span> ToMd5(env, signatureByteArray);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="MD5-对签名进行加密"><a href="#MD5-对签名进行加密" class="headerlink" title="MD5 对签名进行加密"></a>MD5 对签名进行加密</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function">jstring <span class="title">ToMd5</span><span class="params">(JNIEnv *env, jbyteArray source)</span> </span>&#123;</div><div class="line">    <span class="comment">// MessageDigest类</span></div><div class="line">    jclass classMessageDigest = env-&gt;FindClass(<span class="string">"java/security/MessageDigest"</span>);</div><div class="line">    <span class="comment">// MessageDigest.getInstance()静态方法</span></div><div class="line">    jmethodID midGetInstance = env-&gt;GetStaticMethodID(classMessageDigest, <span class="string">"getInstance"</span>,</div><div class="line">                                                      <span class="string">"(Ljava/lang/String;)Ljava/security/MessageDigest;"</span>);</div><div class="line">    <span class="comment">// MessageDigest object</span></div><div class="line">    jobject objMessageDigest = env-&gt;CallStaticObjectMethod(classMessageDigest, midGetInstance,</div><div class="line">                                                           env-&gt;NewStringUTF(<span class="string">"md5"</span>));</div><div class="line"></div><div class="line">    <span class="comment">// update方法，这个函数的返回值是void，写V</span></div><div class="line">    jmethodID midUpdate = env-&gt;GetMethodID(classMessageDigest, <span class="string">"update"</span>, <span class="string">"([B)V"</span>);</div><div class="line">    env-&gt;CallVoidMethod(objMessageDigest, midUpdate, source);</div><div class="line">    <span class="comment">// digest方法</span></div><div class="line">    jmethodID midDigest = env-&gt;GetMethodID(classMessageDigest, <span class="string">"digest"</span>, <span class="string">"()[B"</span>);</div><div class="line">    jbyteArray objArraySign = (jbyteArray) env-&gt;CallObjectMethod(objMessageDigest, midDigest);</div><div class="line">    jsize intArrayLength = env-&gt;GetArrayLength(objArraySign);</div><div class="line">    jbyte *byte_array_elements = env-&gt;GetByteArrayElements(objArraySign, NULL);</div><div class="line">    size_t length = (size_t) intArrayLength * <span class="number">2</span> + <span class="number">1</span>;</div><div class="line">    <span class="keyword">char</span> *char_result = (<span class="keyword">char</span> *) malloc(length);</div><div class="line">    memset(char_result, <span class="number">0</span>, length);</div><div class="line"></div><div class="line">    <span class="comment">// 将byte数组转换成16进制字符串，发现这里不用强转，jbyte和unsigned char应该字节数是一样的</span></div><div class="line">    ByteToHexStr((<span class="keyword">const</span> <span class="keyword">char</span> *) byte_array_elements, char_result, intArrayLength);</div><div class="line">    <span class="comment">// 在末尾补\0</span></div><div class="line">    *(char_result + intArrayLength * <span class="number">2</span>) = <span class="string">'\0'</span>;</div><div class="line"></div><div class="line">    jstring stringResult = env-&gt;NewStringUTF(char_result);</div><div class="line">    <span class="comment">// release</span></div><div class="line">    env-&gt;ReleaseByteArrayElements(objArraySign, byte_array_elements, JNI_ABORT);</div><div class="line">    <span class="comment">// 释放指针使用free</span></div><div class="line">    free(char_result);</div><div class="line">    <span class="keyword">return</span> stringResult;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="byte数组转换成16进制字符串"><a href="#byte数组转换成16进制字符串" class="headerlink" title="byte数组转换成16进制字符串"></a>byte数组转换成16进制字符串</h4><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ByteToHexStr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *source, <span class="keyword">char</span> *dest, <span class="keyword">int</span> sourceLen)</span> </span>&#123;</div><div class="line">    <span class="keyword">short</span> i;</div><div class="line">    <span class="keyword">char</span> highByte, lowByte;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sourceLen; i++) &#123;</div><div class="line">        highByte = source[i] &gt;&gt; <span class="number">4</span>;</div><div class="line">        lowByte = source[i] &amp; <span class="number">0x0f</span>;</div><div class="line">        highByte += <span class="number">0x30</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (highByte &gt; <span class="number">0x39</span>) &#123;</div><div class="line">            dest[i * <span class="number">2</span>] = highByte + <span class="number">0x07</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            dest[i * <span class="number">2</span>] = highByte;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        lowByte += <span class="number">0x30</span>;</div><div class="line">        <span class="keyword">if</span> (lowByte &gt; <span class="number">0x39</span>) &#123;</div><div class="line">            dest[i * <span class="number">2</span> + <span class="number">1</span>] = lowByte + <span class="number">0x07</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            dest[i * <span class="number">2</span> + <span class="number">1</span>] = lowByte;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="创建获取token-key-方法"><a href="#创建获取token-key-方法" class="headerlink" title="创建获取token key 方法"></a>创建获取token key 方法</h4><p>使用场景，很多情况下我们把用户登录后的 token 存储下来，以免下次重新登录。这个时候我们需要使用 token key 对服务端返回下来的 token 进行加密。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> JNIEXPORT jstring JNICALL</div><div class="line">Java_com_laipaiya_jni_MainActivity_getTokenKey</div><div class="line">        (JNIEnv *env, jclass) &#123;</div><div class="line">    <span class="keyword">return</span> env -&gt; NewStringUTF(APP_TOKEN_KEY);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们获得 token key 之后，就可以加密，然后任意存储加密后的数据即可。当我们需要再次使用的时候，只需要对其解密就能得到 token 了。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/02/01/2018-02-01-解决Mac 下 Terminal  Shadowsocks 科学上网/" class="prev">PREV</a><a href="/2017/11/14/2017-11-14-Centos 7 下搭建 LAMP 服务·及 HTTPS/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://www.tipdev.xyz">wkchen</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>