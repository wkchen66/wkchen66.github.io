<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android Native层静态数据安全加密 · wkchen's blog</title><meta name="description" content="Android Native层静态数据安全加密 - wkchen"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.tipdev.xyz/atom.xml" title="wkchen's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">TIMELINE</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android Native层静态数据安全加密</h1><div class="post-info">Feb 1, 2018</div><div class="post-content"><p>整体思路：so 文件在加载时会自动加载 JNI_OnLoad() ，在该方法中对应用签名进行比较，如果签名验证失败，直接在 JNI_OnLoad() 中返回失败。如果验证通过就可以通过 JNI 调用方法获取相应的值。这样可畏是既解决了通常的数据外泄，又解决了 so 文件被提取二次打包造成的重要数据外泄。</p>
<h4 id="加载-so-文件入口"><a href="#加载-so-文件入口" class="headerlink" title="加载 so 文件入口"></a>加载 so 文件入口</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">JNIEXPORT jint JNICALL</div><div class="line">JNI_OnLoad(JavaVM *vm, void *reserved) &#123;</div><div class="line">    JNIEnv *env;</div><div class="line">    LOGI(&quot;  JNI_OnLoad  &quot;);</div><div class="line">    if (vm-&gt;GetEnv((void **) (&amp;env), JNI_VERSION_1_6) != JNI_OK) &#123;</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    LOGI(&quot;start checkSignature&quot;);</div><div class="line">    // 调用验证签名</div><div class="line">    if (checkSignature(env) != JNI_TRUE) &#123;</div><div class="line">        LOGI(&quot;checkSignature error&quot;);</div><div class="line">        // 签名失败</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return JNI_VERSION_1_6;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当签名失败的时候，表示 so 文件加载失败，无法执行后续操作，比如获取 token md5加密 key</p>
<h4 id="通过-Java-反射获取-Context"><a href="#通过-Java-反射获取-Context" class="headerlink" title="通过 Java 反射获取 Context"></a>通过 Java 反射获取 Context</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">static jboolean checkSignature(JNIEnv *env) &#123;</div><div class="line">    // 1.查找 App 的 ContextHolder 类</div><div class="line">    jclass classNativeContextHolder = env-&gt;FindClass(CLASS_NAME_NATIVECONTEXT);</div><div class="line">    // 2.找到 getContext 静态方法</div><div class="line">    jmethodID midGetContext = env-&gt;GetStaticMethodID(classNativeContextHolder,</div><div class="line">                                                     METHOD_NAME_GET_CONTEXT,</div><div class="line">                                                     METHOD_SIGNATURE_GETCONTEXT);</div><div class="line">    // 3.调用 getContext 方法获取 Context 对象</div><div class="line">    jobject appContext = env-&gt;CallStaticObjectMethod(classNativeContextHolder, midGetContext);</div><div class="line"></div><div class="line">    if (appContext != NULL) &#123;</div><div class="line">        jboolean signatureValid = Java_com_laipaiya_jni_MainActivity_checkSignature(</div><div class="line">                env, appContext);</div><div class="line">        return signatureValid;</div><div class="line">    &#125;</div><div class="line">    return JNI_FALSE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用 Java_com_laipaiya_jni_MainActivity_checkSignature 方法比较签名是否想用。</p>
<h4 id="比较当前签名和-release-签名"><a href="#比较当前签名和-release-签名" class="headerlink" title="比较当前签名和 release 签名"></a>比较当前签名和 release 签名</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">extern &quot;C&quot; JNIEXPORT jboolean JNICALL</div><div class="line">Java_com_laipaiya_jni_MainActivity_checkSignature(</div><div class="line">        JNIEnv *env, jobject context) &#123;</div><div class="line">    jstring appSignature = loadSignature(env, context);          // 获取当前签名</div><div class="line">    jstring releaseSignature = env-&gt;NewStringUTF(APP_SIGNATURE); // release 版签名 </div><div class="line">    const char *charAppSignature = env-&gt;GetStringUTFChars(appSignature, NULL);</div><div class="line">    const char *charReleaseSignature = env-&gt;GetStringUTFChars(releaseSignature, NULL);</div><div class="line"></div><div class="line">    LOGI(&quot;  start cmp  getSignature&quot;);</div><div class="line">    __android_log_print(ANDROID_LOG_INFO, LOG_TAG, charAppSignature);</div><div class="line">    LOGI(&quot;  start cmp  getReleaseSignature&quot;);</div><div class="line">    __android_log_print(ANDROID_LOG_INFO, LOG_TAG, charAppSignature);</div><div class="line"></div><div class="line">    jboolean result = JNI_FALSE;</div><div class="line">    // 判断比较是否相等</div><div class="line">    if (charAppSignature != NULL &amp;&amp; charReleaseSignature != NULL) &#123;</div><div class="line">        if (strcmp(charAppSignature, charReleaseSignature) == 0) &#123;</div><div class="line">            result = JNI_TRUE;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    env-&gt;ReleaseStringUTFChars(appSignature, charAppSignature);</div><div class="line">    env-&gt;ReleaseStringUTFChars(releaseSignature, charReleaseSignature);</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="获取当前签名"><a href="#获取当前签名" class="headerlink" title="获取当前签名"></a>获取当前签名</h4><p>获取当前 App 签名，并调用 md5 方法 进行加密</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">jstring loadSignature(JNIEnv *env, jobject context) &#123;</div><div class="line">    // 获得Context类</div><div class="line">    jclass cls = env-&gt;GetObjectClass(context);</div><div class="line">    // 得到getPackageManager方法的ID</div><div class="line">    jmethodID mid = env-&gt;GetMethodID(cls, &quot;getPackageManager&quot;,</div><div class="line">                                     &quot;()Landroid/content/pm/PackageManager;&quot;);</div><div class="line">    // 获得应用包的管理器</div><div class="line">    jobject pm = env-&gt;CallObjectMethod(context, mid);</div><div class="line"></div><div class="line">    // 得到getPackageName方法的ID</div><div class="line">    mid = env-&gt;GetMethodID(cls, &quot;getPackageName&quot;, &quot;()Ljava/lang/String;&quot;);</div><div class="line">    // 获得当前应用包名</div><div class="line">    jstring packageName = (jstring) env-&gt;CallObjectMethod(context, mid);</div><div class="line">    // 获得PackageManager类</div><div class="line">    cls = env-&gt;GetObjectClass(pm);</div><div class="line">    // 得到getPackageInfo方法的ID</div><div class="line">    mid = env-&gt;GetMethodID(cls, &quot;getPackageInfo&quot;,</div><div class="line">                           &quot;(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;&quot;);</div><div class="line">    // 获得应用包的信息</div><div class="line">    jobject packageInfo = env-&gt;CallObjectMethod(pm, mid, packageName, 0x40);        </div><div class="line">    // 获得PackageInfo 类</div><div class="line">    cls = env-&gt;GetObjectClass(packageInfo);</div><div class="line">    // 获得签名数组属性的ID</div><div class="line">    jfieldID fid = env-&gt;GetFieldID(cls, &quot;signatures&quot;, &quot;[Landroid/content/pm/Signature;&quot;);</div><div class="line">    // 得到签名数组</div><div class="line">    jobjectArray signatures = (jobjectArray) env-&gt;GetObjectField(packageInfo, fid);</div><div class="line">    // 得到签名</div><div class="line">    jobject signature = env-&gt;GetObjectArrayElement(signatures, 0);</div><div class="line">    // 获得Signature类</div><div class="line">    cls = env-&gt;GetObjectClass(signature);</div><div class="line">    // 得到toCharsString方法的ID</div><div class="line">    mid = env-&gt;GetMethodID(cls, &quot;toByteArray&quot;, &quot;()[B&quot;);</div><div class="line">    // 返回当前应用签名信息</div><div class="line">    jbyteArray signatureByteArray = (jbyteArray) env-&gt;CallObjectMethod(signature, mid);</div><div class="line">    return ToMd5(env, signatureByteArray);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="MD5-对签名进行加密"><a href="#MD5-对签名进行加密" class="headerlink" title="MD5 对签名进行加密"></a>MD5 对签名进行加密</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">jstring ToMd5(JNIEnv *env, jbyteArray source) &#123;</div><div class="line">    // MessageDigest类</div><div class="line">    jclass classMessageDigest = env-&gt;FindClass(&quot;java/security/MessageDigest&quot;);</div><div class="line">    // MessageDigest.getInstance()静态方法</div><div class="line">    jmethodID midGetInstance = env-&gt;GetStaticMethodID(classMessageDigest, &quot;getInstance&quot;,</div><div class="line">                                                      &quot;(Ljava/lang/String;)Ljava/security/MessageDigest;&quot;);</div><div class="line">    // MessageDigest object</div><div class="line">    jobject objMessageDigest = env-&gt;CallStaticObjectMethod(classMessageDigest, midGetInstance,</div><div class="line">                                                           env-&gt;NewStringUTF(&quot;md5&quot;));</div><div class="line"></div><div class="line">    // update方法，这个函数的返回值是void，写V</div><div class="line">    jmethodID midUpdate = env-&gt;GetMethodID(classMessageDigest, &quot;update&quot;, &quot;([B)V&quot;);</div><div class="line">    env-&gt;CallVoidMethod(objMessageDigest, midUpdate, source);</div><div class="line">    // digest方法</div><div class="line">    jmethodID midDigest = env-&gt;GetMethodID(classMessageDigest, &quot;digest&quot;, &quot;()[B&quot;);</div><div class="line">    jbyteArray objArraySign = (jbyteArray) env-&gt;CallObjectMethod(objMessageDigest, midDigest);</div><div class="line">    jsize intArrayLength = env-&gt;GetArrayLength(objArraySign);</div><div class="line">    jbyte *byte_array_elements = env-&gt;GetByteArrayElements(objArraySign, NULL);</div><div class="line">    size_t length = (size_t) intArrayLength * 2 + 1;</div><div class="line">    char *char_result = (char *) malloc(length);</div><div class="line">    memset(char_result, 0, length);</div><div class="line"></div><div class="line">    // 将byte数组转换成16进制字符串，发现这里不用强转，jbyte和unsigned char应该字节数是一样的</div><div class="line">    ByteToHexStr((const char *) byte_array_elements, char_result, intArrayLength);</div><div class="line">    // 在末尾补\0</div><div class="line">    *(char_result + intArrayLength * 2) = &apos;\0&apos;;</div><div class="line"></div><div class="line">    jstring stringResult = env-&gt;NewStringUTF(char_result);</div><div class="line">    // release</div><div class="line">    env-&gt;ReleaseByteArrayElements(objArraySign, byte_array_elements, JNI_ABORT);</div><div class="line">    // 释放指针使用free</div><div class="line">    free(char_result);</div><div class="line">    return stringResult;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="byte数组转换成16进制字符串"><a href="#byte数组转换成16进制字符串" class="headerlink" title="byte数组转换成16进制字符串"></a>byte数组转换成16进制字符串</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void ByteToHexStr(const char *source, char *dest, int sourceLen) &#123;</div><div class="line">    short i;</div><div class="line">    char highByte, lowByte;</div><div class="line"></div><div class="line">    for (i = 0; i &lt; sourceLen; i++) &#123;</div><div class="line">        highByte = source[i] &gt;&gt; 4;</div><div class="line">        lowByte = source[i] &amp; 0x0f;</div><div class="line">        highByte += 0x30;</div><div class="line"></div><div class="line">        if (highByte &gt; 0x39) &#123;</div><div class="line">            dest[i * 2] = highByte + 0x07;</div><div class="line">        &#125; else &#123;</div><div class="line">            dest[i * 2] = highByte;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        lowByte += 0x30;</div><div class="line">        if (lowByte &gt; 0x39) &#123;</div><div class="line">            dest[i * 2 + 1] = lowByte + 0x07;</div><div class="line">        &#125; else &#123;</div><div class="line">            dest[i * 2 + 1] = lowByte;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="创建获取token-key-方法"><a href="#创建获取token-key-方法" class="headerlink" title="创建获取token key 方法"></a>创建获取token key 方法</h4><p>使用场景，很多情况下我们把用户登录后的 token 存储下来，以免下次重新登录。这个时候我们需要使用 token key 对服务端返回下来的 token 进行加密。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">extern &quot;C&quot; JNIEXPORT jstring JNICALL</div><div class="line">Java_com_laipaiya_jni_MainActivity_getTokenKey</div><div class="line">        (JNIEnv *env, jclass) &#123;</div><div class="line">    return env -&gt; NewStringUTF(APP_TOKEN_KEY);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们获得 token key 之后，就可以加密，然后任意存储加密后的数据即可。当我们需要再次使用的时候，只需要对其解密就能得到 token 了。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/02/01/2018-02-01-解决Mac 下 Terminal 使用 Shadowsocks 科学上网/" class="prev">PREV</a><a href="/2017/11/14/2017-11-14-Centos 7 下搭建 LAMP 服务·及 HTTPS/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://www.tipdev.xyz">wkchen</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>