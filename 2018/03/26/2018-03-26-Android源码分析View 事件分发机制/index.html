<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android 源码分析 View 事件分发机制 · wkchen's blog</title><meta name="description" content="Android 源码分析 View 事件分发机制 - wkchen"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.tipdev.xyz/atom.xml" title="wkchen's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">TIMELINE</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android 源码分析 View 事件分发机制</h1><div class="post-info">Mar 26, 2018</div><div class="post-content"><h3 id="事件分发过程"><a href="#事件分发过程" class="headerlink" title="事件分发过程"></a>事件分发过程</h3><p>一个事件的分发需要以下三个方法共同完成：</p>
<ol>
<li>事件分发：dispatchTouchEvent(MotionEvent ev) </li>
<li>事件拦截：onInterceptTouchEvent(MotionEvent ev) </li>
<li>事件处理：onTouchEvent(MotionEvent ev) </li>
</ol>
<p>分发过程概括：</p>
<p>点击事件产生后，首先传递给 ViewGroup 的 <code>dispatchTouchEvent()</code> 方法，在该方法内调用 <code>onInterceptTouchEvent()</code> 判断是否拦截事件，返回true 表示拦截事件，执行 ViewGroup 的 <code>onTouchEvent()</code> 方法；反之表示不拦截，传递给子 View 的 <code>dispatchTouchEvent()</code>方法，反复操作。</p>
<p><strong>需要注意：</strong></p>
<p>当一个 View 设置了 <code>onTouchListener()</code> 那么它的 <code>onTouch()</code> 事件将被触发，而该 View 的 <code>onTouchEvent()</code> 不会被调用。可以得出 <code>onTouchListener</code> 优先级高于 <code>onTouchEvent</code>。</p>
<p>当一个点击事件产生后，在传递的过程中如果 View 的 <code>onTouchEvent</code> 返回 false，那么它的父 View 的 <code>onTouchEvent</code> 将被调用，以此类推，如果所有 View 都不处理事件，那么最终事件将被反向传递到 Activity 的 <code>onTouchEvent</code></p>
<h3 id="Activity-对点击事件的分发机制"><a href="#Activity-对点击事件的分发机制" class="headerlink" title="Activity 对点击事件的分发机制"></a>Activity 对点击事件的分发机制</h3><p>点击事件产生后，最先传递到 Activity 中，由 <code>dispatchTouchEvent</code> 处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">      onUserInteraction();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 分析1. 获取 window，并调用 window 的 dispatchTouchEvent 方法</span></div><div class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</div><div class="line">      <span class="comment">// 如果 superDispatchTouchEvent 返回 true ，表示事件被 window 中消费了</span></div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> onTouchEvent(ev);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析1:</p>
<p>Activity 首先把事件交给 Window，调用其 <code>superDispatchTouchEvent</code>方法传递事件，如果返回 true，那么直接可以结束整个事件的循环，如果返回 false 表示，事件没有被消费。</p>
<p>这里Window 的唯一实现时 PhoneWindow，接下来看一下 PhoneWindow 中做了什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> DecorView mDecor;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="comment">// 分析2 调用 DecorView 的 dispatchTouchEvent 方法</span></div><div class="line">    <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析2:</p>
<p>看到 PhoneWindow 中 <code>superDispatchTouchEvent</code> 又把事件传递给了 mDecor，mDecor 是一个 DecorView。</p>
<p>那就再进到 DecorView 中看一下做了什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Window.Callback cb = mWindow.getCallback();</div><div class="line">    <span class="keyword">return</span> cb != <span class="keyword">null</span> &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; <span class="number">0</span></div><div class="line">    ? cb.dispatchTouchEvent(ev) : <span class="keyword">super</span>.dispatchTouchEvent(ev);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 DecorView 中看到了有一行 <strong><code>super.dispatchTouchEvent(ev)</code></strong> ，仔细观察你会发现 DecorView 继承自 FrameLayout，而FrameLayout 继承自 ViewGroup ，<strong><code>super.dispatchTouchEvent(ev)</code></strong>是调用父类 ViewGroup 的 <code>dispatchTouchEvent()</code>，看到这里我们大致能读懂 Activity 中事件是真么传递的了。</p>
<h3 id="顶级-View-对点击事件的分发机制"><a href="#顶级-View-对点击事件的分发机制" class="headerlink" title="顶级 View 对点击事件的分发机制"></a>顶级 View 对点击事件的分发机制</h3><p>当点击事件到达顶级 View（一般是 ViewGroup ）后会调用 ViewGroup 的 <code>dispatchTouchEvent</code>，这里就比较复杂了，与前面讲到相同的是：如果 ViewGroup 拦截了事件即 <code>onInterceptToucheEvent</code> 返回 true，则事件有 ViewGroup 处理，这时如果 ViewGroup 设置了 <code>onTouchListener</code> 则调用其 <code>onTouch</code> 方法，反之调用 ViewGroup 的 <code>onTouchEvent</code> 方法；如果 ViewGroup 不拦截，就会把事件分发给子 View，反复循环。</p>
<p>从源码中我们能清晰的看出来以上结论：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 分析3 判断是否拦截事件</span></div><div class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">        || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</div><div class="line">      <span class="keyword">if</span> (!disallowIntercept) &#123;</div><div class="line">        intercepted = onInterceptTouchEvent(ev);</div><div class="line">        ev.setAction(action); </div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        intercepted = <span class="keyword">false</span>;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      intercepted = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析3:</p>
<p>可以看到判断是否拦截事件有两个判断条件，<strong>MotionEvent.ACTION_DOWN</strong> 和 <strong>mFirstTouchTarget</strong>，前者表示事件，那么 mFirstTouchTarget 是什么东西呢？默认 mFirstTouchTarget 肯定是为null 的。这里需要配合接下来的源码分析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> View[] children = mChildren;</div><div class="line"><span class="comment">// 分析4</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</div><div class="line">      childrenCount, i, customOrder);</div><div class="line">    <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</div><div class="line">      preorderedList, children, childIndex);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      childWithAccessibilityFocus = <span class="keyword">null</span>;</div><div class="line">      i = childrenCount - <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</div><div class="line">        || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</div><div class="line">      ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    newTouchTarget = getTouchTarget(child);</div><div class="line">    <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">      newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    resetCancelNextUpFlag(child);</div><div class="line">    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</div><div class="line">      mLastTouchDownTime = ev.getDownTime();</div><div class="line">      <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</div><div class="line">          <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</div><div class="line">            mLastTouchDownIndex = j;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        mLastTouchDownIndex = childIndex;</div><div class="line">      &#125;</div><div class="line">      mLastTouchDownX = ev.getX();</div><div class="line">      mLastTouchDownY = ev.getY();</div><div class="line">      <span class="comment">// 分析5 addTouchTarget()</span></div><div class="line">      newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">      alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析4:</p>
<p>在 dispatchTouchEvent 中有这样一段代码，它循环遍历 ViewGroup 的所有子元素，<strong><code>if (childWithAccessibilityFocus != null)</code></strong>判断是否能接收点击事件，不能接受直接跳过，能接受则继续。再往下看 <strong><code>if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign))</code></strong> ，查看源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></div><div class="line"><span class="function"><span class="params">            View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</div><div class="line">  ...</div><div class="line">  <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</div><div class="line">  <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;event.setAction(MotionEvent.ACTION_CANCEL);</div><div class="line">      <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">          handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">          handled = child.dispatchTouchEvent(event);</div><div class="line">      &#125;</div><div class="line">  event.setAction(oldAction);</div><div class="line">  <span class="keyword">return</span> handled;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上，<code>dispatchTransformedTouchEvent</code> 中调用的是 child 的 <code>dispatchTouchEvent</code>，看到就能明白 ViewGroup 中事件分发传递的过程了。</p>
<p>接着看 ViewGroup <code>dispatchTouchEvent()</code> 中的 <code>addTouchTarget()</code>  源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> TouchTarget <span class="title">addTouchTarget</span><span class="params">(@NonNull View child, <span class="keyword">int</span> pointerIdBits)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> TouchTarget target = TouchTarget.obtain(child, pointerIdBits);</div><div class="line">    target.next = mFirstTouchTarget;</div><div class="line">    <span class="comment">// 分析6 把子View target 赋给 mFirstTouchTarget</span></div><div class="line">    mFirstTouchTarget = target;</div><div class="line">    <span class="keyword">return</span> target;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析5:</p>
<p><strong><code>mFirstTouchTarget = target;</code></strong> 这里把子 View 的 target 赋给 mFirstTouchTarget。恍然大悟，在分析3中，其中一个条件就是 mFirstTouchTarget ，当它不为空并且事件不为 ACTION_DOWN 的时候 ViewGroup 的拦截条件就不成立。</p>
<p><strong> 需要注意: </strong> </p>
<p>当设置了 FLAG_DISALLOW_INTERCEPT 标记位，这个标记位是通过 <code>requestDisallowInterceptTouchEvent</code> 方法设置，一般位于子 View 中。FLAG_DISALLOW_INTERCEPT 设置后， ViewGroup 将无法拦截除了 ACTION_DOWN 以外的点击事件。ACTION_DOWN 事件在 ViewGroup 的<code>dispatchTouchEvent</code> 一开始被重置，导致 FLAG_DISALLOW_INTERCEPT 标记位无效。</p>
<h3 id="View-对点击事件的处理"><a href="#View-对点击事件的处理" class="headerlink" title="View 对点击事件的处理"></a>View 对点击事件的处理</h3><p>不废话，直接看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</div><div class="line">      <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</div><div class="line">        result = <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">      ListenerInfo li = mListenerInfo;</div><div class="line">      <span class="comment">// 分析7</span></div><div class="line">      <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></div><div class="line">          &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</div><div class="line">          &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</div><div class="line">        result = <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</div><div class="line">        result = <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析6:</p>
<p>其中 <strong><code>li.mOnTouchListener != null</code></strong>就是用来判断，当前View 是否设置了 <code>onTouchListener</code>，也验证了之前讲到的设置了 <code>onTouchListener</code> 就不会执行 <code>onTouchEvent</code> 。</p>
<p>如果没有设置 <code>onTouchListener</code> ，<code>onTouchEvent</code> 将被调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    ... </div><div class="line">    <span class="comment">// 分析8</span></div><div class="line">    <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</div><div class="line">      <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</div><div class="line">        setPressed(<span class="keyword">false</span>);</div><div class="line">      &#125;</div><div class="line">      mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</div><div class="line">      <span class="comment">// A disabled view that is clickable still consumes the touch</span></div><div class="line">      <span class="comment">// events, it just doesn't respond to them.</span></div><div class="line">      <span class="keyword">return</span> clickable;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当 View 为不可用状态时，依然会消费点击事件。</p>
<p>相关资料：</p>
<ul>
<li><a href="https://source.android.com/setup/downloading" target="_blank" rel="external">Android 8.0 源码</a></li>
<li><a href="">Android 开发艺术探索</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/02/27/2018-02-27-Android 密钥安全之 密钥库的使用/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://www.tipdev.xyz">wkchen</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>